---
title: "Leaf Collection"
author: "Ed Rogers"
date: "December 22, 2015"
output: html_document
---


Load libraries and import the data
```{r importData, message=FALSE, warning=FALSE}
library(tidyr)
library(dplyr)
library(reshape2)
library(FSA)
library(lazyeval)
library(bizdays)
library(timeDate)
library(ggplot2)

# Read in the data from the CSV. Data comes in very tall and narrow.
# For each visit to the city's website, many observations are made
# (one for each collection area in each district). 
# dcast must be used to reshape the data

leafData <- read.csv("~/Documents/LeafCollection/mapStatuses.csv")
leafData <- leafData[,-which(names(leafData) == "District")]
leafData <- leafData %>% dcast(Time.Stamp ~ Area,value.var="Status")


# Remove consecutive duplicate entries (ignoring differences in timestamp)
#  Done by using a slick hack with rowMeans and booleans. Essentially,
#  the first row is demanded with c(TRUE,...), and all other rows are 
#  compared to their subsequent neighbor (ignoring the first column)
#  and if there are any differences between the neighbors, this row is
#  also kept. Otherwise, it is dropped. To apply this trick, all NA 
#  values must be temporarily switched out with "NA" placeholders, and
#  reverted to NA values afterward.

leafData[is.na(leafData)] <- "NA"
leafData <- leafData[c(TRUE,rowMeans(tail(leafData[,-1],-1) != head(leafData[,-1],-1))>0),]


# Make the timestamp readable
leafData$Time.Stamp <- as.POSIXct(leafData$Time.Stamp,
                                  origin = "1970-01-01",
                                  tz="America/Chicago")


# Using the bizdays library, the number of business days between any two
# rows in the data.frame can be computed.
TimeStamps <- leafData$Time.Stamp
cal <- Calendar(holidayNYSE(2015),weekdays = c("saturday","sunday"))
dates <- data.frame(head(TimeStamps,-1))
colnames(dates) <- "left"
dates$right <- TimeStamps[-1]
datePattern <- "^.*([0-9]{4,4}-[0-9]{2,2}-[0-9]{2,2}).*$"
dates$left <- gsub(datePattern,"\\1",dates[,"left"])
dates$right<- gsub(datePattern,"\\1",dates[,"right"])
dates <- dates %>% mutate(bizDiff = bizdays(left,right,cal))

# # During testing, only examine a few select columns. 
# # Avoid messing with columns that have NA values for now.
# leafData <- leafData[,c("Area10_1","Area1_1","Area4_1")]
leafData <- leafData[,-which(colnames(leafData) == "Time.Stamp")]
# Add a column for collection round for each area
#  First, construct a list of names for these columns
leafDataAreaNames            <- names(leafData)
leafDataCollectionRoundNames <- names(leafData)
leafDataCollectionRoundNames <- setNames(leafDataCollectionRoundNames,paste0("collectionRound_",leafDataAreaNames))
#  Then, fill these columns with a unique number for each round
#  of collections. This is done by finding each time the status
#  is not equal to "Current", but followed by a "Current" in the
#  next row.  Each time this happens a row is marked true. Then,
#  a cumsum is taken over that column, which gives a column that
#  is iterated if-and-only-if a new "Current" status occurs.
leafData <- leafData %>% 
            mutate_each_(funs(cumsum((. != "Current") * (head(c("Current",.),-1) == "Current"))),leafDataCollectionRoundNames) 


# Add a column of nBusinessDaysTilPickup for each Area
#  First, construct a list of names for each column
leafDataNDaysNames           <- names(leafData)
leafDataNDaysNames <- setNames(leafDataNDaysNames,paste0("NDaysTilCollection_",leafDataAreaNames))

#  Then, throw in our pre-computed column of 
#  nBusinessDaysTilNextEntry as a new column
leafData$BusinessDaysTilNextEntry <- c(dates[,"bizDiff"],0)

#  Next, use mutate_each() to copy the nBizDays column once for
#  each area, but zero-ing out the value if the area is "Current"
#   (A dummy function must be used in addition just to get 
#   mutate_each to behave. This set of columns, "..._sd" is
#   immediately discarded)
leafData <- leafData %>%
              mutate_each(funs(nBusinessDaysTilPickup=(as.numeric(. != "Current")*BusinessDaysTilNextEntry),sd=is.na),starts_with("Area"))
leafData <- leafData %>%
  select(-contains("_sd"))

# Next, using collectionRound_ for each Area as a grouping
# variable, perform a cumsum on nBusinessDaysTilPickup

for (col in leafDataAreaNames)
{
  rnd <- paste0("collectionRound_",col)
  ndays <- paste0(col,"_nBusinessDaysTilPickup")
  leafData <- leafData %>%
                    group_by_(paste(rnd)) %>%
                    mutate_(ndays=interp(~rcumsum(ndays),ndays=as.name(ndays))) %>%
                    ungroup()
  leafData[[ndays]]=leafData$ndays
  leafData <- leafData %>% select(-ndays)
}

leafDataCollectionRounds <- leafData %>% select(starts_with("collectionRound_"))

# Lastly, cleanup the data.frame by removing the grouping variable
# and row-by-row nBizDays computations. Reintroduce the TimeStamp.
leafData <- leafData %>% 
  select(-starts_with("collectionRound_")) %>%
  select(-starts_with("BusinessDaysTilNextEntry"))
leafDataNames <- names(leafData)
leafData[leafData=="NA"] <- NA
leafData <- cbind(TimeStamps,leafData)

```

```{r buildArea10Predictor, message=FALSE,warning=FALSE}
#First, look only at even numbered districts
leafDataWest <- leafData %>%
  select(-starts_with("Area01")) %>%
  select(-starts_with("Area03")) %>%
  select(-starts_with("Area05")) %>%
  select(-starts_with("Area07")) %>%
  select(-starts_with("Area09"))

# Now, build summary columns for each area
areaStatus <- function(num,df) 
{
  out <- rep("Done",nrow(df))
  out[rowSums(df %>% select(starts_with(paste("Area",num,sep = ""))) == "Not Done") > 0] <- "Not Done"
  out[rowSums(df %>% select(starts_with(paste("Area",num,sep = ""))) == "Next") > 0] <- "Next"
  out[rowSums(df %>% select(starts_with(paste("Area",num,sep = ""))) == "Current") > 0] <- "Current"
  out
}

leafDataWest$Area02Status <- areaStatus("02",leafDataWest)
leafDataWest$Area04Status <- areaStatus("04",leafDataWest)
leafDataWest$Area06Status <- areaStatus("06",leafDataWest)
leafDataWest$Area08Status <- areaStatus("08",leafDataWest)
leafDataWest$Area10Status <- areaStatus("10",leafDataWest)

# Select only columns useful for regression: 
#  dependent variable: my particular nBusinessDays column for this regression
#  independent vars: All status columns in this district +
#                    all status columns in the previous district +
#                    summary status columns for other 3 districts
dependent_var <- leafDataWest[,"Area10_001_nBusinessDaysTilPickup"]
leafData10_001 <- leafDataWest %>%
  select(-matches('Area02_+')) %>%
  select(-matches("Area04_+")) %>%
  select(-matches("Area06_+")) %>%
  select(-matches("Area08Status")) %>%
  select(-matches("Area10Status")) %>%
  select(-matches("TimeStamps")) %>%
  select(-ends_with("Pickup"))
leafData10_001[] <- lapply(leafData10_001, factor)
leafData10_001$nDays <- dependent_var

# fit <- lm(nDays ~ .,data=leafData10_001)
# 
# testRow <- leafData10_001[c(18,22),] %>% select(-matches("nDays"))
# testRow$Area10_023 <- leafData10_001[c(15,3),"Area10_023"]
# testRow$Area08_001 <- leafData10_001[c(4,20),"Area08_001"]
# predict.lm(fit,testRow)
# leafData10_001[c(18,22),"nDays"]

dependent_var <- leafDataWest[,"Area10_001_nBusinessDaysTilPickup"]
leafData10_001 <- leafDataWest %>% select(ends_with("Status"))
leafData10_001[] <- lapply(leafData10_001, factor)
leafData10_001$nDays <- dependent_var

fit <- lm(nDays ~ .,data=leafData10_001)

testRow <- leafData10_001[c(18,24),] %>% select(-matches("nDays"))
testRow$Area04Status <- leafData10_001[c(19,27),"Area04Status"]
testRow$Area06Status <- leafData10_001[c(18,25),"Area06Status"]
rownames(testRow) <- c("A","B")
summary(fit)
#predict.lm(fit,testRow)
leafData10_001[c(18,22),"nDays"]
```

```{r alternatePredictor, message=FALSE, warning=FALSE}
# Select only the columns for Area Statuses
leafDataWestStatuses <- leafDataWest %>%
  select(matches("Area[0-9]+_[0-9]+$"))

# Choose an area of interest
targetArea <- "Area02_026"
# targetArea <- "Area04_004"
# targetArea <- "Area08_001"
# Assign dependent variable to a vector
targetAreaValName <- paste(targetArea,"_nBusinessDaysTilPickup",sep="")
nDaysTilPickup <- leafDataWest[,targetAreaValName]

collectionRound <- leafDataCollectionRounds[,paste("collectionRound_",targetArea,sep="")]

# Drop any rows that lack "Current" status
rowsWithCurrent <- rowSums(leafDataWestStatuses=="Current")>0
nDaysTilPickup <- nDaysTilPickup[rowsWithCurrent]
leafDataWestStatuses <- leafDataWestStatuses[rowsWithCurrent,]
collectionRound <- collectionRound[rowsWithCurrent,]

# Rearrange data.frame so that target area is last column
#  Column order is otherwise unchanged. ("Cut the deck")
targetAreaCol <- which(colnames(leafDataWestStatuses) %in% targetArea)
nextColNum <- (targetAreaCol)%%ncol(leafDataWestStatuses)+1
lastColNum <- ncol(leafDataWestStatuses)
if (targetAreaCol != lastColNum) {
  leafDataWestStatuses <- leafDataWestStatuses[,c(nextColNum:lastColNum,1:targetAreaCol)]
}

# Find column number of last "Current" status
testFunc <- function(x) tail(colnames(leafDataWestStatuses)[x=="Current"],1)
out <- apply(leafDataWestStatuses,1,testFunc)
nColsFromCurrent <- match(out,colnames(leafDataWestStatuses))

# Build a data.frame with independent & dependent variables
modelData <- data.frame(nDaysTilPickup,nColsFromCurrent)
# Make a regression from my 2 vars
fit <- lm(nDaysTilPickup ~ nColsFromCurrent, data=modelData)

# Create a feature that indicates (True/False) whether a "Current" status
#   was observed in the last three rows.
status <- leafDataWestStatuses[,targetArea]
recentPickup <- status=="Current" | c("Done",head(status,-1))=="Current" | c("Done","Done",head(status,-2))=="Current"
recentPickupAndDone <- as.factor(recentPickup & status=="Done")

modelData$status <- as.factor(status)
modelData$status <- relevel(modelData$status,ref="Done")
modelData$recentPickupAndDone <- recentPickupAndDone

# Mask out data from after last pickup (nDaysTilPickup is artificially small)
afterLastPickup <- rcumsum(as.numeric(status=="Current"))==0
modelData <- modelData[!afterLastPickup,]

fit2 <- lm(nDaysTilPickup ~ ., data=modelData)

# modelData$collectionRound <- as.factor(collectionRound[[1]])
# fit2 <- lm(nDaysTilPickup ~ ., data=modelData)

ggplot(data=modelData,aes(x=nColsFromCurrent,y=nDaysTilPickup)) +
geom_jitter(aes(colour=factor(recentPickupAndDone)),size=3) +
stat_smooth(method="lm",col="blue")

```


```{r trainDecisionTree, message=FALSE, warning=FALSE, eval=FALSE}
library(rpart)

#First, let's just try to figure out Area10_1 based on the last 17 rows of data


leafData_subset <- leafData %>%
  select(-ends_with("Pickup")) %>%
  select(-starts_with("Time"))
leafData_subset <- leafData_subset[c(21:37),]
leafData_subset$n <- leafData[c(21:37),"Area10_001_nBusinessDaysTilPickup"]
#leafData_subset

fit <- rpart(n ~ ., data=leafData_subset, minsplit=2)
par(mfrow = c(1,2), xpd = NA) # otherwise on some devices the text is clipped
plot(fit)
text(fit, use.n = TRUE)

```

A thought: compress the dataset before training like so:

To train on Area10_5 reduce data.frame down to
Statuses of all areas in District 10
Statuses of all areas in District 8 (the "previous" district)
True/False factor: Does District 6 have a "Current" Area?
True/False factor: Does District 4 have a "Current" Area?
True/False factor: Does District 2 have a "Current" Area?

This should reduce training from 221 inputs to ~47.
